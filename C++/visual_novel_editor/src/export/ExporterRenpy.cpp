#include "ExporterRenpy.h"

#include <QFile>
#include <QList>
#include <QStringList>
#include <QTextDocument>
#include <QTextStream>
#include <Qt>
#include <QtGlobal>

#include "ScriptFormatter.h"
#include "model/Choice.h"
#include "model/Project.h"
#include "model/StoryNode.h"

ExporterRenpy::ExporterRenpy(Project *project)
    : m_project(project)
{
}

void ExporterRenpy::setSelectedNodeIds(const QStringList &nodeIds)
{
    m_selectionOrder.clear();
    m_selectedNodeIds.clear();

    for (const QString &id : nodeIds) {
        if (id.isEmpty() || m_selectedNodeIds.contains(id)) {
            continue;
        }
        m_selectionOrder.append(id);
        m_selectedNodeIds.insert(id);
    }
}

bool ExporterRenpy::exportToFile(const QString &fileName)
{
    if (!m_project) {
        return false;
    }

    QFile file(fileName);
    if (!file.open(QIODevice::WriteOnly | QIODevice::Text)) {
        return false;
    }

    QTextStream out(&file);
    out << "# Generated by Visual Novel Editor\n\n";

    const QStringList order = exportOrder();

    if (order.isEmpty()) {
        reportProgress();
        return true;
    }

    m_visited.clear();
    m_processedNodes = 0;
    m_wasCanceled = false;
    if (hasSelection()) {
        m_totalNodes = m_selectedNodeIds.size();
    } else {
        m_totalNodes = countReachableNodes(order.front());
        if (m_totalNodes == 0) {
            m_totalNodes = m_project->nodes().size();
        }
    }
    if (!reportProgress()) {
        m_wasCanceled = true;
        return false;
    }

    if (hasSelection()) {
        for (const QString &nodeId : order) {
            if (!generateNode(nodeId, out, 0)) {
                return false;
            }
        }
    } else {
        if (!generateNode(order.front(), out, 0)) {
            return false;
        }
    }

    if (m_processedNodes < m_totalNodes) {
        m_processedNodes = m_totalNodes;
        reportProgress();
    }

    return !m_wasCanceled;
}

void ExporterRenpy::setProgressCallback(std::function<bool(int, int)> callback)
{
    m_progressCallback = std::move(callback);
}

bool ExporterRenpy::generateNode(const QString &nodeId, QTextStream &out, int indent)
{
    if (nodeId.isEmpty() || m_visited.contains(nodeId)) {
        return true;
    }

    if (hasSelection() && !m_selectedNodeIds.contains(nodeId)) {
        return true;
    }

    m_visited.insert(nodeId);
    StoryNode *node = m_project->getNode(nodeId);
    if (!node) {
        return true;
    }

    out << "label " << nodeId << ":\n";

    QTextDocument document;
    const QString script = node->script();
    if (Qt::mightBeRichText(script)) {
        document.setHtml(script);
    } else {
        document.setPlainText(script);
    }
    const QStringList lines = document.toPlainText().split('\n');
    for (const QString &line : lines) {
        out << ScriptFormatter::indent(indent + 4) << line.trimmed() << '\n';
    }

    QList<Choice> exportedChoices;
    exportedChoices.reserve(node->choices().size());
    for (const Choice &choice : node->choices()) {
        if (!hasSelection() || m_selectedNodeIds.contains(choice.targetNodeId)) {
            exportedChoices.append(choice);
        }
    }

    if (!exportedChoices.isEmpty()) {
        out << ScriptFormatter::indent(indent + 4) << "menu:\n";
        for (const Choice &choice : exportedChoices) {
            out << ScriptFormatter::indent(indent + 8);
            if (choice.condition.has_value()) {
                out << "if " << choice.condition.value() << ": ";
            }
            out << '"' << choice.text << '"' << ":\n";
            out << ScriptFormatter::indent(indent + 12) << "jump " << choice.targetNodeId << '\n';
        }
    } else {
        out << ScriptFormatter::indent(indent + 4) << "# TODO: define next action\n";
    }

    out << '\n';

    ++m_processedNodes;
    if (!reportProgress()) {
        m_wasCanceled = true;
        return false;
    }

    for (const Choice &choice : exportedChoices) {
        if (!generateNode(choice.targetNodeId, out, indent)) {
            return false;
        }
    }

    return true;
}

bool ExporterRenpy::reportProgress() const
{
    if (!m_progressCallback) {
        return true;
    }

    const int total = m_totalNodes <= 0 ? m_project->nodes().size() : m_totalNodes;
    const int processed = qMin(m_processedNodes, total);
    return m_progressCallback(processed, total > 0 ? total : 0);
}

int ExporterRenpy::countReachableNodes(const QString &startId) const
{
    if (!m_project || startId.isEmpty()) {
        return 0;
    }

    const Project *project = m_project;
    QSet<QString> visited;
    QList<QString> toVisit;
    toVisit.append(startId);

    while (!toVisit.isEmpty()) {
        const QString current = toVisit.takeFirst();
        if (current.isEmpty() || visited.contains(current)) {
            continue;
        }
        visited.insert(current);

        const StoryNode *node = project->getNode(current);
        if (!node) {
            continue;
        }
        for (const Choice &choice : node->choices()) {
            toVisit.append(choice.targetNodeId);
        }
    }

    return visited.size();
}

QStringList ExporterRenpy::exportOrder() const
{
    if (hasSelection()) {
        return m_selectionOrder;
    }
    return m_project ? m_project->nodes().keys() : QStringList{};
}
